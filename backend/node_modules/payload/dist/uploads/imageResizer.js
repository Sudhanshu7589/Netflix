"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that dos not need to be resized, an result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ const createImageName = (outputImageName, { height, width }, extension)=>`${outputImageName}-${width}x${height}.${extension}`;
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = ({ name, filename = null, filesize = null, height = null, mimeType = null, sizesToSave = [], width = null })=>{
    return {
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    };
};
/**
 * Check if the image needs to be resized according to the requested dimensions
 * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,
 * the image will be resized regardless of the requested dimensions, given that the
 * width or height to be resized is provided.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if resizing is not needed, false otherwise
 */ const preventResize = ({ height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }, original)=>{
    // default is to allow reduction
    if (withoutReduction !== undefined) {
        return false // needs resize
        ;
    }
    // default is to prevent enlargement
    if (withoutEnlargement !== undefined) {
        return false // needs resize
        ;
    }
    const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth;
    if (isWidthOrHeightNotDefined) {
        // If width and height are not defined, it means there is a format conversion
        // and the image needs to be "resized" (transformed).
        return false // needs resize
        ;
    }
    const hasInsufficientWidth = desiredWidth > original.width;
    const hasInsufficientHeight = desiredHeight > original.height;
    if (hasInsufficientWidth && hasInsufficientHeight) {
        // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.
        // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image
        // should be resized to the sufficient dimension.
        return true // do not create a new size
        ;
    }
    return false // needs resize
    ;
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath, uploadEdits }) {
    const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload;
    // Focal point adjustments
    const incomingFocalPoint = uploadEdits?.focalPoint ? {
        x: (0, _isNumber.isNumber)(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
        y: (0, _isNumber.isNumber)(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50
    } : undefined;
    const defaultResult = {
        ...focalPointEnabled && incomingFocalPoint && {
            focalPoint: incomingFocalPoint
        },
        sizeData: {},
        sizesToSave: []
    };
    // Nothing to resize here so return as early as possible
    if (!imageSizes) return defaultResult;
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        // This checks if a resize should happen. If not, the resized image will be
        // skipped COMPLETELY and thus will not be included in the resulting images.
        // All further format/trim options will thus be skipped as well.
        if (preventResize(imageResizeConfig, dimensions)) {
            return createResult({
                name: imageResizeConfig.name
            });
        }
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        if (incomingFocalPoint && applyPayloadAdjustments(imageResizeConfig, dimensions)) {
            const { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const originalAspectRatio = dimensions.width / dimensions.height;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scale the image up or down to fit the resize dimensions
            const scaledImage = imageToResize.resize({
                height: prioritizeHeight ? resizeHeight : null,
                width: prioritizeHeight ? null : resizeWidth
            });
            const { info: scaledImageInfo } = await scaledImage.toBuffer({
                resolveWithObject: true
            });
            const safeResizeWidth = resizeWidth ?? scaledImageInfo.width;
            const maxOffsetX = scaledImageInfo.width - safeResizeWidth;
            const leftFocalEdge = Math.round(scaledImageInfo.width * (incomingFocalPoint.x / 100) - safeResizeWidth / 2);
            const safeOffsetX = Math.min(Math.max(0, leftFocalEdge), maxOffsetX);
            const safeResizeHeight = resizeHeight ?? scaledImageInfo.height;
            const maxOffsetY = scaledImageInfo.height - safeResizeHeight;
            const topFocalEdge = Math.round(scaledImageInfo.height * (incomingFocalPoint.y / 100) - safeResizeHeight / 2);
            const safeOffsetY = Math.min(Math.max(0, topFocalEdge), maxOffsetY);
            // extract the focal area from the scaled image
            resized = scaledImage.extract({
                height: safeResizeHeight,
                left: safeOffsetX,
                top: safeOffsetY,
                width: safeResizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName(sanitizedImage.name, bufferInfo, mimeInfo?.ext || sanitizedImage.ext);
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult({
            name: imageResizeConfig.name,
            filename: imageNameWithDimensions,
            filesize: size,
            height,
            mimeType: mimeInfo?.mime || mimeType,
            sizesToSave: [
                {
                    buffer: bufferData,
                    path: imagePath
                }
            ],
            width
        });
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, defaultResult);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgT3V0cHV0SW5mbyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFNhbml0aXplZENvbGxlY3Rpb25Db25maWcgfSBmcm9tICcuLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmlsZVNpemUsXG4gIEZpbGVTaXplcyxcbiAgRmlsZVRvU2F2ZSxcbiAgSW1hZ2VTaXplLFxuICBQcm9iZWRJbWFnZVNpemUsXG4gIFVwbG9hZEVkaXRzLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4uL3V0aWxpdGllcy9pc051bWJlcidcbmltcG9ydCBmaWxlRXhpc3RzIGZyb20gJy4vZmlsZUV4aXN0cydcblxudHlwZSBSZXNpemVBcmdzID0ge1xuICBjb25maWc6IFNhbml0aXplZENvbGxlY3Rpb25Db25maWdcbiAgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplXG4gIGZpbGU6IFVwbG9hZGVkRmlsZVxuICBtaW1lVHlwZTogc3RyaW5nXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgc2F2ZWRGaWxlbmFtZTogc3RyaW5nXG4gIHN0YXRpY1BhdGg6IHN0cmluZ1xuICB1cGxvYWRFZGl0cz86IFVwbG9hZEVkaXRzXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgZm9jYWxQb2ludD86IFVwbG9hZEVkaXRzWydmb2NhbFBvaW50J11cbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cbmNvbnN0IGNyZWF0ZUltYWdlTmFtZSA9IChcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmcsXG4gIHsgaGVpZ2h0LCB3aWR0aCB9OiBPdXRwdXRJbmZvLFxuICBleHRlbnNpb246IHN0cmluZyxcbikgPT4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxuXG50eXBlIENyZWF0ZVJlc3VsdEFyZ3MgPSB7XG4gIGZpbGVuYW1lPzogRmlsZVNpemVbJ2ZpbGVuYW1lJ11cbiAgZmlsZXNpemU/OiBGaWxlU2l6ZVsnZmlsZXNpemUnXVxuICBoZWlnaHQ/OiBGaWxlU2l6ZVsnaGVpZ2h0J11cbiAgbWltZVR5cGU/OiBGaWxlU2l6ZVsnbWltZVR5cGUnXVxuICBuYW1lOiBzdHJpbmdcbiAgc2l6ZXNUb1NhdmU/OiBGaWxlVG9TYXZlW11cbiAgd2lkdGg/OiBGaWxlU2l6ZVsnd2lkdGgnXVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKHtcbiAgbmFtZSxcbiAgZmlsZW5hbWUgPSBudWxsLFxuICBmaWxlc2l6ZSA9IG51bGwsXG4gIGhlaWdodCA9IG51bGwsXG4gIG1pbWVUeXBlID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmUgPSBbXSxcbiAgd2lkdGggPSBudWxsLFxufTogQ3JlYXRlUmVzdWx0QXJncyk6IEltYWdlU2l6ZXNSZXN1bHQgPT4ge1xuICByZXR1cm4ge1xuICAgIHNpemVEYXRhOiB7XG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZpbGVzaXplLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzaXplc1RvU2F2ZSxcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnNcbiAqIGFuZCB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS4gSWYgdGhlIHJlc2l6ZSBvcHRpb25zIHdpdGhvdXRFbmxhcmdlbWVudCBvciB3aXRob3V0UmVkdWN0aW9uIGFyZSBwcm92aWRlZCxcbiAqIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgcmVnYXJkbGVzcyBvZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMsIGdpdmVuIHRoYXQgdGhlXG4gKiB3aWR0aCBvciBoZWlnaHQgdG8gYmUgcmVzaXplZCBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgcmVzaXppbmcgaXMgbm90IG5lZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IHByZXZlbnRSZXNpemUgPSAoXG4gIHsgaGVpZ2h0OiBkZXNpcmVkSGVpZ2h0LCB3aWR0aDogZGVzaXJlZFdpZHRoLCB3aXRob3V0RW5sYXJnZW1lbnQsIHdpdGhvdXRSZWR1Y3Rpb24gfTogSW1hZ2VTaXplLFxuICBvcmlnaW5hbDogUHJvYmVkSW1hZ2VTaXplLFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIGRlZmF1bHQgaXMgdG8gYWxsb3cgcmVkdWN0aW9uXG4gIGlmICh3aXRob3V0UmVkdWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICAvLyBkZWZhdWx0IGlzIHRvIHByZXZlbnQgZW5sYXJnZW1lbnRcbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5lZWRzIHJlc2l6ZVxuICB9XG5cbiAgY29uc3QgaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCA9ICFkZXNpcmVkSGVpZ2h0IHx8ICFkZXNpcmVkV2lkdGhcbiAgaWYgKGlzV2lkdGhPckhlaWdodE5vdERlZmluZWQpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZGVmaW5lZCwgaXQgbWVhbnMgdGhlcmUgaXMgYSBmb3JtYXQgY29udmVyc2lvblxuICAgIC8vIGFuZCB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgXCJyZXNpemVkXCIgKHRyYW5zZm9ybWVkKS5cbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICBjb25zdCBoYXNJbnN1ZmZpY2llbnRXaWR0aCA9IGRlc2lyZWRXaWR0aCA+IG9yaWdpbmFsLndpZHRoXG4gIGNvbnN0IGhhc0luc3VmZmljaWVudEhlaWdodCA9IGRlc2lyZWRIZWlnaHQgPiBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKGhhc0luc3VmZmljaWVudFdpZHRoICYmIGhhc0luc3VmZmljaWVudEhlaWdodCkge1xuICAgIC8vIGRvZXNuJ3QgbmVlZCByZXNpemUgLSBwcmV2ZW50IGVubGFyZ2VtZW50LiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGluc3VmZmljaWVudC5cbiAgICAvLyBpZiBvbmx5IG9uZSBkaW1lbnNpb24gaXMgaW5zdWZmaWNpZW50IGFuZCB0aGUgb3RoZXIgaXMgc3VmZmljaWVudCwgcmVzaXppbmcgbmVlZHMgdG8gaGFwcGVuLCBhcyB0aGUgaW1hZ2VcbiAgICAvLyBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgc3VmZmljaWVudCBkaW1lbnNpb24uXG4gICAgcmV0dXJuIHRydWUgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBzaXplXG4gIH1cblxuICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGltYWdlIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gc2hhcnAgd2l0aG91dCBwYXlsb2FkIGFkanVzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYW5kIHJlc2l6ZSBvcHRpb25zXG4gKiBAcGFyYW0gb3JpZ2luYWwgLSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIHBhc3NlZCBkaXJlY3RseSB0byBzaGFycFxuICovXG5jb25zdCBhcHBseVBheWxvYWRBZGp1c3RtZW50cyA9IChcbiAgeyBmaXQsIGhlaWdodCwgd2lkdGgsIHdpdGhvdXRFbmxhcmdlbWVudCwgd2l0aG91dFJlZHVjdGlvbiB9OiBJbWFnZVNpemUsXG4gIG9yaWdpbmFsOiBQcm9iZWRJbWFnZVNpemUsXG4pID0+IHtcbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nIHx8IGZpdCA9PT0gJ2luc2lkZScpIHJldHVybiBmYWxzZVxuICBpZiAoIWlzTnVtYmVyKGhlaWdodCkgJiYgIWlzTnVtYmVyKHdpZHRoKSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodFxuICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gb3JpZ2luYWwud2lkdGggLyBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKG9yaWdpbmFsQXNwZWN0UmF0aW8gPT09IHRhcmdldEFzcGVjdFJhdGlvKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBza2lwRW5sYXJnZW1lbnQgPSB3aXRob3V0RW5sYXJnZW1lbnQgJiYgKG9yaWdpbmFsLmhlaWdodCA8IGhlaWdodCB8fCBvcmlnaW5hbC53aWR0aCA8IHdpZHRoKVxuICBjb25zdCBza2lwUmVkdWN0aW9uID0gd2l0aG91dFJlZHVjdGlvbiAmJiAob3JpZ2luYWwuaGVpZ2h0ID4gaGVpZ2h0IHx8IG9yaWdpbmFsLndpZHRoID4gd2lkdGgpXG4gIGlmIChza2lwRW5sYXJnZW1lbnQgfHwgc2tpcFJlZHVjdGlvbikgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgcmVzaXplIGNvbmZpZy4gSWYgdGhlIHJlc2l6ZSBjb25maWcgaGFzIHRoZSBgd2l0aG91dFJlZHVjdGlvbmBcbiAqIHByb3BlcnR5IHNldCB0byB0cnVlLCB0aGUgYGZpdGAgYW5kIGBwb3NpdGlvbmAgcHJvcGVydGllcyB3aWxsIGJlIHNldCB0byBgY29udGFpbmBcbiAqIGFuZCBgdG9wIGxlZnRgIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIGEgc2FuaXRpemVkIHJlc2l6ZSBjb25maWdcbiAqL1xuY29uc3Qgc2FuaXRpemVSZXNpemVDb25maWcgPSAocmVzaXplQ29uZmlnOiBJbWFnZVNpemUpOiBJbWFnZVNpemUgPT4ge1xuICBpZiAocmVzaXplQ29uZmlnLndpdGhvdXRSZWR1Y3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzaXplQ29uZmlnLFxuICAgICAgLy8gV2h5IGZpdCBgY29udGFpbmAgc2hvdWxkIGFsc28gYmUgc2V0IHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvaXNzdWVzLzM1OTVcbiAgICAgIGZpdDogcmVzaXplQ29uZmlnPy5maXQgfHwgJ2NvbnRhaW4nLFxuICAgICAgcG9zaXRpb246IHJlc2l6ZUNvbmZpZz8ucG9zaXRpb24gfHwgJ2xlZnQgdG9wJyxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2l6ZUNvbmZpZ1xufVxuXG4vKipcbiAqIEZvciB0aGUgcHJvdmlkZWQgaW1hZ2Ugc2l6ZXMsIGhhbmRsZSB0aGUgcmVzaXppbmcgYW5kIHRoZSB0cmFuc2Zvcm1zXG4gKiAoZm9ybWF0LCB0cmltLCBldGMuKSBvZiBlYWNoIHJlcXVlc3RlZCBpbWFnZSBzaXplIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvYmplY3QuXG4gKiBUaGlzIG9ubHkgaGFuZGxlcyB0aGUgaW1hZ2Ugc2l6ZXMuIFRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICogYXJlIGhhbmRsZWQgaW4ge0BsaW5rIC4vZ2VuZXJhdGVGaWxlRGF0YS50c30uXG4gKlxuICogVGhlIGltYWdlIHdpbGwgYmUgcmVzaXplZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gKiByZXNpemUgY29uZmlnLiBJZiBubyBpbWFnZSBzaXplcyBhcmUgcmVxdWVzdGVkLCB0aGUgcmVzb2x2ZWQgZGF0YSB3aWxsIGJlIGVtcHR5LlxuICogRm9yIGV2ZXJ5IGltYWdlIHRoYXQgZG9zIG5vdCBuZWVkIHRvIGJlIHJlc2l6ZWQsIGFuIHJlc3VsdCBvYmplY3Qgd2l0aCBgbnVsbGBcbiAqIHBhcmFtZXRlcnMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHJlc2l6ZSBvcGVyYXRpb24ocylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyh7XG4gIGNvbmZpZyxcbiAgZGltZW5zaW9ucyxcbiAgZmlsZSxcbiAgbWltZVR5cGUsXG4gIHJlcSxcbiAgc2F2ZWRGaWxlbmFtZSxcbiAgc3RhdGljUGF0aCxcbiAgdXBsb2FkRWRpdHMsXG59OiBSZXNpemVBcmdzKTogUHJvbWlzZTxJbWFnZVNpemVzUmVzdWx0PiB7XG4gIGNvbnN0IHsgZm9jYWxQb2ludDogZm9jYWxQb2ludEVuYWJsZWQgPSB0cnVlLCBpbWFnZVNpemVzIH0gPSBjb25maWcudXBsb2FkXG5cbiAgLy8gRm9jYWwgcG9pbnQgYWRqdXN0bWVudHNcbiAgY29uc3QgaW5jb21pbmdGb2NhbFBvaW50ID0gdXBsb2FkRWRpdHM/LmZvY2FsUG9pbnRcbiAgICA/IHtcbiAgICAgICAgeDogaXNOdW1iZXIodXBsb2FkRWRpdHMuZm9jYWxQb2ludC54KSA/IE1hdGgucm91bmQodXBsb2FkRWRpdHMuZm9jYWxQb2ludC54KSA6IDUwLFxuICAgICAgICB5OiBpc051bWJlcih1cGxvYWRFZGl0cy5mb2NhbFBvaW50LnkpID8gTWF0aC5yb3VuZCh1cGxvYWRFZGl0cy5mb2NhbFBvaW50LnkpIDogNTAsXG4gICAgICB9XG4gICAgOiB1bmRlZmluZWRcblxuICBjb25zdCBkZWZhdWx0UmVzdWx0OiBJbWFnZVNpemVzUmVzdWx0ID0ge1xuICAgIC4uLihmb2NhbFBvaW50RW5hYmxlZCAmJiBpbmNvbWluZ0ZvY2FsUG9pbnQgJiYgeyBmb2NhbFBvaW50OiBpbmNvbWluZ0ZvY2FsUG9pbnQgfSksXG4gICAgc2l6ZURhdGE6IHt9LFxuICAgIHNpemVzVG9TYXZlOiBbXSxcbiAgfVxuXG4gIC8vIE5vdGhpbmcgdG8gcmVzaXplIGhlcmUgc28gcmV0dXJuIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG4gIGlmICghaW1hZ2VTaXplcykgcmV0dXJuIGRlZmF1bHRSZXN1bHRcblxuICBjb25zdCBzaGFycEJhc2UgPSBzaGFycChmaWxlLnRlbXBGaWxlUGF0aCB8fCBmaWxlLmRhdGEpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuXG4gIGNvbnN0IHJlc3VsdHM6IEltYWdlU2l6ZXNSZXN1bHRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGltYWdlU2l6ZXMubWFwKGFzeW5jIChpbWFnZVJlc2l6ZUNvbmZpZyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4gPT4ge1xuICAgICAgaW1hZ2VSZXNpemVDb25maWcgPSBzYW5pdGl6ZVJlc2l6ZUNvbmZpZyhpbWFnZVJlc2l6ZUNvbmZpZylcblxuICAgICAgLy8gVGhpcyBjaGVja3MgaWYgYSByZXNpemUgc2hvdWxkIGhhcHBlbi4gSWYgbm90LCB0aGUgcmVzaXplZCBpbWFnZSB3aWxsIGJlXG4gICAgICAvLyBza2lwcGVkIENPTVBMRVRFTFkgYW5kIHRodXMgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBpbWFnZXMuXG4gICAgICAvLyBBbGwgZnVydGhlciBmb3JtYXQvdHJpbSBvcHRpb25zIHdpbGwgdGh1cyBiZSBza2lwcGVkIGFzIHdlbGwuXG4gICAgICBpZiAocHJldmVudFJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZywgZGltZW5zaW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdCh7IG5hbWU6IGltYWdlUmVzaXplQ29uZmlnLm5hbWUgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemVcblxuICAgICAgaWYgKGluY29taW5nRm9jYWxQb2ludCAmJiBhcHBseVBheWxvYWRBZGp1c3RtZW50cyhpbWFnZVJlc2l6ZUNvbmZpZywgZGltZW5zaW9ucykpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQ6IHJlc2l6ZUhlaWdodCwgd2lkdGg6IHJlc2l6ZVdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuICAgICAgICBjb25zdCByZXNpemVBc3BlY3RSYXRpbyA9IHJlc2l6ZVdpZHRoIC8gcmVzaXplSGVpZ2h0XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgY29uc3QgcHJpb3JpdGl6ZUhlaWdodCA9IHJlc2l6ZUFzcGVjdFJhdGlvIDwgb3JpZ2luYWxBc3BlY3RSYXRpb1xuXG4gICAgICAgIC8vIFNjYWxlIHRoZSBpbWFnZSB1cCBvciBkb3duIHRvIGZpdCB0aGUgcmVzaXplIGRpbWVuc2lvbnNcbiAgICAgICAgY29uc3Qgc2NhbGVkSW1hZ2UgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZSh7XG4gICAgICAgICAgaGVpZ2h0OiBwcmlvcml0aXplSGVpZ2h0ID8gcmVzaXplSGVpZ2h0IDogbnVsbCxcbiAgICAgICAgICB3aWR0aDogcHJpb3JpdGl6ZUhlaWdodCA/IG51bGwgOiByZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgeyBpbmZvOiBzY2FsZWRJbWFnZUluZm8gfSA9IGF3YWl0IHNjYWxlZEltYWdlLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSlcblxuICAgICAgICBjb25zdCBzYWZlUmVzaXplV2lkdGggPSByZXNpemVXaWR0aCA/PyBzY2FsZWRJbWFnZUluZm8ud2lkdGhcbiAgICAgICAgY29uc3QgbWF4T2Zmc2V0WCA9IHNjYWxlZEltYWdlSW5mby53aWR0aCAtIHNhZmVSZXNpemVXaWR0aFxuICAgICAgICBjb25zdCBsZWZ0Rm9jYWxFZGdlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBzY2FsZWRJbWFnZUluZm8ud2lkdGggKiAoaW5jb21pbmdGb2NhbFBvaW50LnggLyAxMDApIC0gc2FmZVJlc2l6ZVdpZHRoIC8gMixcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBzYWZlT2Zmc2V0WCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGxlZnRGb2NhbEVkZ2UpLCBtYXhPZmZzZXRYKVxuXG4gICAgICAgIGNvbnN0IHNhZmVSZXNpemVIZWlnaHQgPSByZXNpemVIZWlnaHQgPz8gc2NhbGVkSW1hZ2VJbmZvLmhlaWdodFxuICAgICAgICBjb25zdCBtYXhPZmZzZXRZID0gc2NhbGVkSW1hZ2VJbmZvLmhlaWdodCAtIHNhZmVSZXNpemVIZWlnaHRcbiAgICAgICAgY29uc3QgdG9wRm9jYWxFZGdlID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0ICogKGluY29taW5nRm9jYWxQb2ludC55IC8gMTAwKSAtIHNhZmVSZXNpemVIZWlnaHQgLyAyLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHNhZmVPZmZzZXRZID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdG9wRm9jYWxFZGdlKSwgbWF4T2Zmc2V0WSlcblxuICAgICAgICAvLyBleHRyYWN0IHRoZSBmb2NhbCBhcmVhIGZyb20gdGhlIHNjYWxlZCBpbWFnZVxuICAgICAgICByZXNpemVkID0gc2NhbGVkSW1hZ2UuZXh0cmFjdCh7XG4gICAgICAgICAgaGVpZ2h0OiBzYWZlUmVzaXplSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IHNhZmVPZmZzZXRYLFxuICAgICAgICAgIHRvcDogc2FmZU9mZnNldFksXG4gICAgICAgICAgd2lkdGg6IHNhZmVSZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2l6ZWQgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZylcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudG9Gb3JtYXQoXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5vcHRpb25zLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucykge1xuICAgICAgICByZXNpemVkID0gcmVzaXplZC50cmltKGltYWdlUmVzaXplQ29uZmlnLnRyaW1PcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGE6IGJ1ZmZlckRhdGEsIGluZm86IGJ1ZmZlckluZm8gfSA9IGF3YWl0IHJlc2l6ZWQudG9CdWZmZXIoe1xuICAgICAgICByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNhbml0aXplZEltYWdlID0gZ2V0U2FuaXRpemVkSW1hZ2VEYXRhKHNhdmVkRmlsZW5hbWUpXG5cbiAgICAgIGlmIChyZXEucGF5bG9hZFVwbG9hZFNpemVzKSB7XG4gICAgICAgIHJlcS5wYXlsb2FkVXBsb2FkU2l6ZXNbaW1hZ2VSZXNpemVDb25maWcubmFtZV0gPSBidWZmZXJEYXRhXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pbWVJbmZvID0gYXdhaXQgZnJvbUJ1ZmZlcihidWZmZXJEYXRhKVxuXG4gICAgICBjb25zdCBpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyA9IGNyZWF0ZUltYWdlTmFtZShcbiAgICAgICAgc2FuaXRpemVkSW1hZ2UubmFtZSxcbiAgICAgICAgYnVmZmVySW5mbyxcbiAgICAgICAgbWltZUluZm8/LmV4dCB8fCBzYW5pdGl6ZWRJbWFnZS5leHQsXG4gICAgICApXG5cbiAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGAke3N0YXRpY1BhdGh9LyR7aW1hZ2VOYW1lV2l0aERpbWVuc2lvbnN9YFxuXG4gICAgICBpZiAoYXdhaXQgZmlsZUV4aXN0cyhpbWFnZVBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhpbWFnZVBhdGgpXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElnbm9yZSB1bmxpbmsgZXJyb3JzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBoZWlnaHQsIHNpemUsIHdpZHRoIH0gPSBidWZmZXJJbmZvXG4gICAgICByZXR1cm4gY3JlYXRlUmVzdWx0KHtcbiAgICAgICAgbmFtZTogaW1hZ2VSZXNpemVDb25maWcubmFtZSxcbiAgICAgICAgZmlsZW5hbWU6IGltYWdlTmFtZVdpdGhEaW1lbnNpb25zLFxuICAgICAgICBmaWxlc2l6ZTogc2l6ZSxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBtaW1lVHlwZTogbWltZUluZm8/Lm1pbWUgfHwgbWltZVR5cGUsXG4gICAgICAgIHNpemVzVG9TYXZlOiBbeyBidWZmZXI6IGJ1ZmZlckRhdGEsIHBhdGg6IGltYWdlUGF0aCB9XSxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9KVxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2MsIHJlc3VsdCkgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oYWNjLnNpemVEYXRhLCByZXN1bHQuc2l6ZURhdGEpXG4gICAgYWNjLnNpemVzVG9TYXZlLnB1c2goLi4ucmVzdWx0LnNpemVzVG9TYXZlKVxuICAgIHJldHVybiBhY2NcbiAgfSwgZGVmYXVsdFJlc3VsdClcbn1cbiJdLCJuYW1lcyI6WyJyZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIiwiZ2V0U2FuaXRpemVkSW1hZ2VEYXRhIiwic291cmNlSW1hZ2UiLCJleHRlbnNpb24iLCJzcGxpdCIsInBvcCIsIm5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZXh0IiwiY3JlYXRlSW1hZ2VOYW1lIiwib3V0cHV0SW1hZ2VOYW1lIiwiaGVpZ2h0Iiwid2lkdGgiLCJjcmVhdGVSZXN1bHQiLCJmaWxlbmFtZSIsImZpbGVzaXplIiwibWltZVR5cGUiLCJzaXplc1RvU2F2ZSIsInNpemVEYXRhIiwicHJldmVudFJlc2l6ZSIsImRlc2lyZWRIZWlnaHQiLCJkZXNpcmVkV2lkdGgiLCJ3aXRob3V0RW5sYXJnZW1lbnQiLCJ3aXRob3V0UmVkdWN0aW9uIiwib3JpZ2luYWwiLCJ1bmRlZmluZWQiLCJpc1dpZHRoT3JIZWlnaHROb3REZWZpbmVkIiwiaGFzSW5zdWZmaWNpZW50V2lkdGgiLCJoYXNJbnN1ZmZpY2llbnRIZWlnaHQiLCJhcHBseVBheWxvYWRBZGp1c3RtZW50cyIsImZpdCIsImlzTnVtYmVyIiwidGFyZ2V0QXNwZWN0UmF0aW8iLCJvcmlnaW5hbEFzcGVjdFJhdGlvIiwic2tpcEVubGFyZ2VtZW50Iiwic2tpcFJlZHVjdGlvbiIsInNhbml0aXplUmVzaXplQ29uZmlnIiwicmVzaXplQ29uZmlnIiwicG9zaXRpb24iLCJjb25maWciLCJkaW1lbnNpb25zIiwiZmlsZSIsInJlcSIsInNhdmVkRmlsZW5hbWUiLCJzdGF0aWNQYXRoIiwidXBsb2FkRWRpdHMiLCJmb2NhbFBvaW50IiwiZm9jYWxQb2ludEVuYWJsZWQiLCJpbWFnZVNpemVzIiwidXBsb2FkIiwiaW5jb21pbmdGb2NhbFBvaW50IiwieCIsIk1hdGgiLCJyb3VuZCIsInkiLCJkZWZhdWx0UmVzdWx0Iiwic2hhcnBCYXNlIiwic2hhcnAiLCJ0ZW1wRmlsZVBhdGgiLCJkYXRhIiwicm90YXRlIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJpbWFnZVJlc2l6ZUNvbmZpZyIsImltYWdlVG9SZXNpemUiLCJjbG9uZSIsInJlc2l6ZWQiLCJyZXNpemVIZWlnaHQiLCJyZXNpemVXaWR0aCIsInJlc2l6ZUFzcGVjdFJhdGlvIiwicHJpb3JpdGl6ZUhlaWdodCIsInNjYWxlZEltYWdlIiwicmVzaXplIiwiaW5mbyIsInNjYWxlZEltYWdlSW5mbyIsInRvQnVmZmVyIiwicmVzb2x2ZVdpdGhPYmplY3QiLCJzYWZlUmVzaXplV2lkdGgiLCJtYXhPZmZzZXRYIiwibGVmdEZvY2FsRWRnZSIsInNhZmVPZmZzZXRYIiwibWluIiwibWF4Iiwic2FmZVJlc2l6ZUhlaWdodCIsIm1heE9mZnNldFkiLCJ0b3BGb2NhbEVkZ2UiLCJzYWZlT2Zmc2V0WSIsImV4dHJhY3QiLCJsZWZ0IiwidG9wIiwiZm9ybWF0T3B0aW9ucyIsInRvRm9ybWF0IiwiZm9ybWF0Iiwib3B0aW9ucyIsInRyaW1PcHRpb25zIiwidHJpbSIsImJ1ZmZlckRhdGEiLCJidWZmZXJJbmZvIiwic2FuaXRpemVkSW1hZ2UiLCJwYXlsb2FkVXBsb2FkU2l6ZXMiLCJtaW1lSW5mbyIsImZyb21CdWZmZXIiLCJpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyIsImltYWdlUGF0aCIsImZpbGVFeGlzdHMiLCJmcyIsInVubGlua1N5bmMiLCJzaXplIiwibWltZSIsImJ1ZmZlciIsInBhdGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHQiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7OytCQW1OQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0Q7OztlQUE4QkE7OzswQkE5Tkg7MkRBQ1o7eUVBQ007OERBQ0g7MEJBYU87bUVBQ0Y7Ozs7OztBQXlCdkI7Ozs7O0NBS0MsR0FDRCxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsTUFBTUMsWUFBWUQsWUFBWUUsS0FBSyxDQUFDLEtBQUtDLEdBQUc7SUFDNUMsTUFBTUMsT0FBT0MsSUFBQUEseUJBQVEsRUFBQ0wsWUFBWU0sU0FBUyxDQUFDLEdBQUdOLFlBQVlPLFdBQVcsQ0FBQyxTQUFTUDtJQUNoRixPQUFPO1FBQUVJO1FBQU1JLEtBQUtQO0lBQVU7QUFDaEM7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxNQUFNUSxrQkFBa0IsQ0FDdEJDLGlCQUNBLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFjLEVBQzdCWCxZQUNHLENBQUMsRUFBRVMsZ0JBQWdCLENBQUMsRUFBRUUsTUFBTSxDQUFDLEVBQUVELE9BQU8sQ0FBQyxFQUFFVixVQUFVLENBQUM7QUFZekQ7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELE1BQU1ZLGVBQWUsQ0FBQyxFQUNwQlQsSUFBSSxFQUNKVSxXQUFXLElBQUksRUFDZkMsV0FBVyxJQUFJLEVBQ2ZKLFNBQVMsSUFBSSxFQUNiSyxXQUFXLElBQUksRUFDZkMsY0FBYyxFQUFFLEVBQ2hCTCxRQUFRLElBQUksRUFDSztJQUNqQixPQUFPO1FBQ0xNLFVBQVU7WUFDUixDQUFDZCxLQUFLLEVBQUU7Z0JBQ05VO2dCQUNBQztnQkFDQUo7Z0JBQ0FLO2dCQUNBSjtZQUNGO1FBQ0Y7UUFDQUs7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUUsZ0JBQWdCLENBQ3BCLEVBQUVSLFFBQVFTLGFBQWEsRUFBRVIsT0FBT1MsWUFBWSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQWEsRUFDL0ZDO0lBRUEsZ0NBQWdDO0lBQ2hDLElBQUlELHFCQUFxQkUsV0FBVztRQUNsQyxPQUFPLE1BQU0sZUFBZTs7SUFDOUI7SUFFQSxvQ0FBb0M7SUFDcEMsSUFBSUgsdUJBQXVCRyxXQUFXO1FBQ3BDLE9BQU8sTUFBTSxlQUFlOztJQUM5QjtJQUVBLE1BQU1DLDRCQUE0QixDQUFDTixpQkFBaUIsQ0FBQ0M7SUFDckQsSUFBSUssMkJBQTJCO1FBQzdCLDZFQUE2RTtRQUM3RSxxREFBcUQ7UUFDckQsT0FBTyxNQUFNLGVBQWU7O0lBQzlCO0lBRUEsTUFBTUMsdUJBQXVCTixlQUFlRyxTQUFTWixLQUFLO0lBQzFELE1BQU1nQix3QkFBd0JSLGdCQUFnQkksU0FBU2IsTUFBTTtJQUM3RCxJQUFJZ0Isd0JBQXdCQyx1QkFBdUI7UUFDakQsZ0hBQWdIO1FBQ2hILDRHQUE0RztRQUM1RyxpREFBaUQ7UUFDakQsT0FBTyxLQUFLLDJCQUEyQjs7SUFDekM7SUFFQSxPQUFPLE1BQU0sZUFBZTs7QUFDOUI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNQywwQkFBMEIsQ0FDOUIsRUFBRUMsR0FBRyxFQUFFbkIsTUFBTSxFQUFFQyxLQUFLLEVBQUVVLGtCQUFrQixFQUFFQyxnQkFBZ0IsRUFBYSxFQUN2RUM7SUFFQSxJQUFJTSxRQUFRLGFBQWFBLFFBQVEsVUFBVSxPQUFPO0lBQ2xELElBQUksQ0FBQ0MsSUFBQUEsa0JBQVEsRUFBQ3BCLFdBQVcsQ0FBQ29CLElBQUFBLGtCQUFRLEVBQUNuQixRQUFRLE9BQU87SUFFbEQsTUFBTW9CLG9CQUFvQnBCLFFBQVFEO0lBQ2xDLE1BQU1zQixzQkFBc0JULFNBQVNaLEtBQUssR0FBR1ksU0FBU2IsTUFBTTtJQUM1RCxJQUFJc0Isd0JBQXdCRCxtQkFBbUIsT0FBTztJQUV0RCxNQUFNRSxrQkFBa0JaLHNCQUF1QkUsQ0FBQUEsU0FBU2IsTUFBTSxHQUFHQSxVQUFVYSxTQUFTWixLQUFLLEdBQUdBLEtBQUk7SUFDaEcsTUFBTXVCLGdCQUFnQlosb0JBQXFCQyxDQUFBQSxTQUFTYixNQUFNLEdBQUdBLFVBQVVhLFNBQVNaLEtBQUssR0FBR0EsS0FBSTtJQUM1RixJQUFJc0IsbUJBQW1CQyxlQUFlLE9BQU87SUFFN0MsT0FBTztBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1DLHVCQUF1QixDQUFDQztJQUM1QixJQUFJQSxhQUFhZCxnQkFBZ0IsRUFBRTtRQUNqQyxPQUFPO1lBQ0wsR0FBR2MsWUFBWTtZQUNmLHNGQUFzRjtZQUN0RlAsS0FBS08sY0FBY1AsT0FBTztZQUMxQlEsVUFBVUQsY0FBY0MsWUFBWTtRQUN0QztJQUNGO0lBQ0EsT0FBT0Q7QUFDVDtBQWdCZSxlQUFldkMsNkJBQTZCLEVBQ3pEeUMsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLElBQUksRUFDSnpCLFFBQVEsRUFDUjBCLEdBQUcsRUFDSEMsYUFBYSxFQUNiQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDQTtJQUNYLE1BQU0sRUFBRUMsWUFBWUMsb0JBQW9CLElBQUksRUFBRUMsVUFBVSxFQUFFLEdBQUdULE9BQU9VLE1BQU07SUFFMUUsMEJBQTBCO0lBQzFCLE1BQU1DLHFCQUFxQkwsYUFBYUMsYUFDcEM7UUFDRUssR0FBR3BCLElBQUFBLGtCQUFRLEVBQUNjLFlBQVlDLFVBQVUsQ0FBQ0ssQ0FBQyxJQUFJQyxLQUFLQyxLQUFLLENBQUNSLFlBQVlDLFVBQVUsQ0FBQ0ssQ0FBQyxJQUFJO1FBQy9FRyxHQUFHdkIsSUFBQUEsa0JBQVEsRUFBQ2MsWUFBWUMsVUFBVSxDQUFDUSxDQUFDLElBQUlGLEtBQUtDLEtBQUssQ0FBQ1IsWUFBWUMsVUFBVSxDQUFDUSxDQUFDLElBQUk7SUFDakYsSUFDQTdCO0lBRUosTUFBTThCLGdCQUFrQztRQUN0QyxHQUFJUixxQkFBcUJHLHNCQUFzQjtZQUFFSixZQUFZSTtRQUFtQixDQUFDO1FBQ2pGaEMsVUFBVSxDQUFDO1FBQ1hELGFBQWEsRUFBRTtJQUNqQjtJQUVBLHdEQUF3RDtJQUN4RCxJQUFJLENBQUMrQixZQUFZLE9BQU9PO0lBRXhCLE1BQU1DLFlBQVlDLElBQUFBLGNBQUssRUFBQ2hCLEtBQUtpQixZQUFZLElBQUlqQixLQUFLa0IsSUFBSSxFQUFFQyxNQUFNLEdBQUcsbUdBQW1HOztJQUVwSyxNQUFNQyxVQUE4QixNQUFNQyxRQUFRQyxHQUFHLENBQ25EZixXQUFXZ0IsR0FBRyxDQUFDLE9BQU9DO1FBQ3BCQSxvQkFBb0I3QixxQkFBcUI2QjtRQUV6QywyRUFBMkU7UUFDM0UsNEVBQTRFO1FBQzVFLGdFQUFnRTtRQUNoRSxJQUFJOUMsY0FBYzhDLG1CQUFtQnpCLGFBQWE7WUFDaEQsT0FBTzNCLGFBQWE7Z0JBQUVULE1BQU02RCxrQkFBa0I3RCxJQUFJO1lBQUM7UUFDckQ7UUFFQSxNQUFNOEQsZ0JBQWdCVixVQUFVVyxLQUFLO1FBQ3JDLElBQUlDLFVBQVVGO1FBRWQsSUFBSWhCLHNCQUFzQnJCLHdCQUF3Qm9DLG1CQUFtQnpCLGFBQWE7WUFDaEYsTUFBTSxFQUFFN0IsUUFBUTBELFlBQVksRUFBRXpELE9BQU8wRCxXQUFXLEVBQUUsR0FBR0w7WUFDckQsTUFBTU0sb0JBQW9CRCxjQUFjRDtZQUN4QyxNQUFNcEMsc0JBQXNCTyxXQUFXNUIsS0FBSyxHQUFHNEIsV0FBVzdCLE1BQU07WUFDaEUsTUFBTTZELG1CQUFtQkQsb0JBQW9CdEM7WUFFN0MsMERBQTBEO1lBQzFELE1BQU13QyxjQUFjUCxjQUFjUSxNQUFNLENBQUM7Z0JBQ3ZDL0QsUUFBUTZELG1CQUFtQkgsZUFBZTtnQkFDMUN6RCxPQUFPNEQsbUJBQW1CLE9BQU9GO1lBQ25DO1lBQ0EsTUFBTSxFQUFFSyxNQUFNQyxlQUFlLEVBQUUsR0FBRyxNQUFNSCxZQUFZSSxRQUFRLENBQUM7Z0JBQUVDLG1CQUFtQjtZQUFLO1lBRXZGLE1BQU1DLGtCQUFrQlQsZUFBZU0sZ0JBQWdCaEUsS0FBSztZQUM1RCxNQUFNb0UsYUFBYUosZ0JBQWdCaEUsS0FBSyxHQUFHbUU7WUFDM0MsTUFBTUUsZ0JBQWdCN0IsS0FBS0MsS0FBSyxDQUM5QnVCLGdCQUFnQmhFLEtBQUssR0FBSXNDLENBQUFBLG1CQUFtQkMsQ0FBQyxHQUFHLEdBQUUsSUFBSzRCLGtCQUFrQjtZQUUzRSxNQUFNRyxjQUFjOUIsS0FBSytCLEdBQUcsQ0FBQy9CLEtBQUtnQyxHQUFHLENBQUMsR0FBR0gsZ0JBQWdCRDtZQUV6RCxNQUFNSyxtQkFBbUJoQixnQkFBZ0JPLGdCQUFnQmpFLE1BQU07WUFDL0QsTUFBTTJFLGFBQWFWLGdCQUFnQmpFLE1BQU0sR0FBRzBFO1lBQzVDLE1BQU1FLGVBQWVuQyxLQUFLQyxLQUFLLENBQzdCdUIsZ0JBQWdCakUsTUFBTSxHQUFJdUMsQ0FBQUEsbUJBQW1CSSxDQUFDLEdBQUcsR0FBRSxJQUFLK0IsbUJBQW1CO1lBRTdFLE1BQU1HLGNBQWNwQyxLQUFLK0IsR0FBRyxDQUFDL0IsS0FBS2dDLEdBQUcsQ0FBQyxHQUFHRyxlQUFlRDtZQUV4RCwrQ0FBK0M7WUFDL0NsQixVQUFVSyxZQUFZZ0IsT0FBTyxDQUFDO2dCQUM1QjlFLFFBQVEwRTtnQkFDUkssTUFBTVI7Z0JBQ05TLEtBQUtIO2dCQUNMNUUsT0FBT21FO1lBQ1Q7UUFDRixPQUFPO1lBQ0xYLFVBQVVGLGNBQWNRLE1BQU0sQ0FBQ1Q7UUFDakM7UUFFQSxJQUFJQSxrQkFBa0IyQixhQUFhLEVBQUU7WUFDbkN4QixVQUFVQSxRQUFReUIsUUFBUSxDQUN4QjVCLGtCQUFrQjJCLGFBQWEsQ0FBQ0UsTUFBTSxFQUN0QzdCLGtCQUFrQjJCLGFBQWEsQ0FBQ0csT0FBTztRQUUzQztRQUVBLElBQUk5QixrQkFBa0IrQixXQUFXLEVBQUU7WUFDakM1QixVQUFVQSxRQUFRNkIsSUFBSSxDQUFDaEMsa0JBQWtCK0IsV0FBVztRQUN0RDtRQUVBLE1BQU0sRUFBRXJDLE1BQU11QyxVQUFVLEVBQUV2QixNQUFNd0IsVUFBVSxFQUFFLEdBQUcsTUFBTS9CLFFBQVFTLFFBQVEsQ0FBQztZQUNwRUMsbUJBQW1CO1FBQ3JCO1FBRUEsTUFBTXNCLGlCQUFpQnJHLHNCQUFzQjRDO1FBRTdDLElBQUlELElBQUkyRCxrQkFBa0IsRUFBRTtZQUMxQjNELElBQUkyRCxrQkFBa0IsQ0FBQ3BDLGtCQUFrQjdELElBQUksQ0FBQyxHQUFHOEY7UUFDbkQ7UUFFQSxNQUFNSSxXQUFXLE1BQU1DLElBQUFBLG9CQUFVLEVBQUNMO1FBRWxDLE1BQU1NLDBCQUEwQi9GLGdCQUM5QjJGLGVBQWVoRyxJQUFJLEVBQ25CK0YsWUFDQUcsVUFBVTlGLE9BQU80RixlQUFlNUYsR0FBRztRQUdyQyxNQUFNaUcsWUFBWSxDQUFDLEVBQUU3RCxXQUFXLENBQUMsRUFBRTRELHdCQUF3QixDQUFDO1FBRTVELElBQUksTUFBTUUsSUFBQUEsbUJBQVUsRUFBQ0QsWUFBWTtZQUMvQixJQUFJO2dCQUNGRSxXQUFFLENBQUNDLFVBQVUsQ0FBQ0g7WUFDaEIsRUFBRSxPQUFNO1lBQ04sdUJBQXVCO1lBQ3pCO1FBQ0Y7UUFFQSxNQUFNLEVBQUU5RixNQUFNLEVBQUVrRyxJQUFJLEVBQUVqRyxLQUFLLEVBQUUsR0FBR3VGO1FBQ2hDLE9BQU90RixhQUFhO1lBQ2xCVCxNQUFNNkQsa0JBQWtCN0QsSUFBSTtZQUM1QlUsVUFBVTBGO1lBQ1Z6RixVQUFVOEY7WUFDVmxHO1lBQ0FLLFVBQVVzRixVQUFVUSxRQUFROUY7WUFDNUJDLGFBQWE7Z0JBQUM7b0JBQUU4RixRQUFRYjtvQkFBWWMsTUFBTVA7Z0JBQVU7YUFBRTtZQUN0RDdGO1FBQ0Y7SUFDRjtJQUdGLE9BQU9pRCxRQUFRb0QsTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQzFCQyxPQUFPQyxNQUFNLENBQUNILElBQUloRyxRQUFRLEVBQUVpRyxPQUFPakcsUUFBUTtRQUMzQ2dHLElBQUlqRyxXQUFXLENBQUNxRyxJQUFJLElBQUlILE9BQU9sRyxXQUFXO1FBQzFDLE9BQU9pRztJQUNULEdBQUczRDtBQUNMIn0=