"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _getTranslation = require("../../../../utilities/getTranslation");
const _Plus = /*#__PURE__*/ _interop_require_default(require("../../icons/Plus"));
const _X = /*#__PURE__*/ _interop_require_default(require("../../icons/X"));
const _EditDepth = require("../../utilities/EditDepth");
const _DraggableSortable = /*#__PURE__*/ _interop_require_default(require("../DraggableSortable"));
const _Pill = /*#__PURE__*/ _interop_require_default(require("../Pill"));
const _TableColumns = require("../TableColumns");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'column-selector';
const ColumnSelector = (props)=>{
    const { slug } = props;
    const { columns, moveColumn, toggleColumn } = (0, _TableColumns.useTableColumns)();
    const { i18n } = (0, _reacti18next.useTranslation)();
    const uuid = (0, _react.useId)();
    const editDepth = (0, _EditDepth.useEditDepth)();
    if (!columns) {
        return null;
    }
    return /*#__PURE__*/ _react.default.createElement(_DraggableSortable.default, {
        className: baseClass,
        ids: columns.map((col)=>col.accessor),
        onDragEnd: ({ moveFromIndex, moveToIndex })=>{
            moveColumn({
                fromIndex: moveFromIndex,
                toIndex: moveToIndex
            });
        }
    }, columns.map((col, i)=>{
        const { name, accessor, active, label } = col;
        if (col.accessor === '_select') return null;
        return /*#__PURE__*/ _react.default.createElement(_Pill.default, {
            alignIcon: "left",
            "aria-checked": active,
            className: [
                `${baseClass}__column`,
                active && `${baseClass}__column--active`
            ].filter(Boolean).join(' '),
            draggable: true,
            icon: active ? /*#__PURE__*/ _react.default.createElement(_X.default, null) : /*#__PURE__*/ _react.default.createElement(_Plus.default, null),
            id: accessor,
            key: `${slug}-${col.name || i}${editDepth ? `-${editDepth}-` : ''}${uuid}`,
            onClick: ()=>{
                toggleColumn(accessor);
            }
        }, (0, _getTranslation.getTranslation)(label || name, i18n));
    }));
};
const _default = ColumnSelector;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL0NvbHVtblNlbGVjdG9yL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlSWQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL2dldFRyYW5zbGF0aW9uJ1xuaW1wb3J0IFBsdXMgZnJvbSAnLi4vLi4vaWNvbnMvUGx1cydcbmltcG9ydCBYIGZyb20gJy4uLy4uL2ljb25zL1gnXG5pbXBvcnQgeyB1c2VFZGl0RGVwdGggfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvRWRpdERlcHRoJ1xuaW1wb3J0IERyYWdnYWJsZVNvcnRhYmxlIGZyb20gJy4uL0RyYWdnYWJsZVNvcnRhYmxlJ1xuaW1wb3J0IFBpbGwgZnJvbSAnLi4vUGlsbCdcbmltcG9ydCB7IHVzZVRhYmxlQ29sdW1ucyB9IGZyb20gJy4uL1RhYmxlQ29sdW1ucydcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnY29sdW1uLXNlbGVjdG9yJ1xuXG5jb25zdCBDb2x1bW5TZWxlY3RvcjogUmVhY3QuRkM8UHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgc2x1ZyB9ID0gcHJvcHNcblxuICBjb25zdCB7IGNvbHVtbnMsIG1vdmVDb2x1bW4sIHRvZ2dsZUNvbHVtbiB9ID0gdXNlVGFibGVDb2x1bW5zKClcblxuICBjb25zdCB7IGkxOG4gfSA9IHVzZVRyYW5zbGF0aW9uKClcbiAgY29uc3QgdXVpZCA9IHVzZUlkKClcbiAgY29uc3QgZWRpdERlcHRoID0gdXNlRWRpdERlcHRoKClcblxuICBpZiAoIWNvbHVtbnMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8RHJhZ2dhYmxlU29ydGFibGVcbiAgICAgIGNsYXNzTmFtZT17YmFzZUNsYXNzfVxuICAgICAgaWRzPXtjb2x1bW5zLm1hcCgoY29sKSA9PiBjb2wuYWNjZXNzb3IpfVxuICAgICAgb25EcmFnRW5kPXsoeyBtb3ZlRnJvbUluZGV4LCBtb3ZlVG9JbmRleCB9KSA9PiB7XG4gICAgICAgIG1vdmVDb2x1bW4oe1xuICAgICAgICAgIGZyb21JbmRleDogbW92ZUZyb21JbmRleCxcbiAgICAgICAgICB0b0luZGV4OiBtb3ZlVG9JbmRleCxcbiAgICAgICAgfSlcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NvbHVtbnMubWFwKChjb2wsIGkpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBhY2Nlc3NvciwgYWN0aXZlLCBsYWJlbCB9ID0gY29sXG5cbiAgICAgICAgaWYgKGNvbC5hY2Nlc3NvciA9PT0gJ19zZWxlY3QnKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPFBpbGxcbiAgICAgICAgICAgIGFsaWduSWNvbj1cImxlZnRcIlxuICAgICAgICAgICAgYXJpYS1jaGVja2VkPXthY3RpdmV9XG4gICAgICAgICAgICBjbGFzc05hbWU9e1tgJHtiYXNlQ2xhc3N9X19jb2x1bW5gLCBhY3RpdmUgJiYgYCR7YmFzZUNsYXNzfV9fY29sdW1uLS1hY3RpdmVgXVxuICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgICAgICBkcmFnZ2FibGVcbiAgICAgICAgICAgIGljb249e2FjdGl2ZSA/IDxYIC8+IDogPFBsdXMgLz59XG4gICAgICAgICAgICBpZD17YWNjZXNzb3J9XG4gICAgICAgICAgICBrZXk9e2Ake3NsdWd9LSR7Y29sLm5hbWUgfHwgaX0ke2VkaXREZXB0aCA/IGAtJHtlZGl0RGVwdGh9LWAgOiAnJ30ke3V1aWR9YH1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgdG9nZ2xlQ29sdW1uKGFjY2Vzc29yKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Z2V0VHJhbnNsYXRpb24obGFiZWwgfHwgbmFtZSwgaTE4bil9XG4gICAgICAgICAgPC9QaWxsPlxuICAgICAgICApXG4gICAgICB9KX1cbiAgICA8L0RyYWdnYWJsZVNvcnRhYmxlPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbHVtblNlbGVjdG9yXG4iXSwibmFtZXMiOlsiYmFzZUNsYXNzIiwiQ29sdW1uU2VsZWN0b3IiLCJwcm9wcyIsInNsdWciLCJjb2x1bW5zIiwibW92ZUNvbHVtbiIsInRvZ2dsZUNvbHVtbiIsInVzZVRhYmxlQ29sdW1ucyIsImkxOG4iLCJ1c2VUcmFuc2xhdGlvbiIsInV1aWQiLCJ1c2VJZCIsImVkaXREZXB0aCIsInVzZUVkaXREZXB0aCIsIkRyYWdnYWJsZVNvcnRhYmxlIiwiY2xhc3NOYW1lIiwiaWRzIiwibWFwIiwiY29sIiwiYWNjZXNzb3IiLCJvbkRyYWdFbmQiLCJtb3ZlRnJvbUluZGV4IiwibW92ZVRvSW5kZXgiLCJmcm9tSW5kZXgiLCJ0b0luZGV4IiwiaSIsIm5hbWUiLCJhY3RpdmUiLCJsYWJlbCIsIlBpbGwiLCJhbGlnbkljb24iLCJhcmlhLWNoZWNrZWQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRyYWdnYWJsZSIsImljb24iLCJYIiwiUGx1cyIsImlkIiwia2V5Iiwib25DbGljayIsImdldFRyYW5zbGF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9FQTs7O2VBQUE7OzsrREFwRTZCOzhCQUNFO2dDQUlBOzZEQUNkOzBEQUNIOzJCQUNlOzBFQUNDOzZEQUNiOzhCQUNlO1FBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLE1BQU1BLFlBQVk7QUFFbEIsTUFBTUMsaUJBQWtDLENBQUNDO0lBQ3ZDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdEO0lBRWpCLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFlBQVksRUFBRSxHQUFHQyxJQUFBQSw2QkFBZTtJQUU3RCxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHQyxJQUFBQSw0QkFBYztJQUMvQixNQUFNQyxPQUFPQyxJQUFBQSxZQUFLO0lBQ2xCLE1BQU1DLFlBQVlDLElBQUFBLHVCQUFZO0lBRTlCLElBQUksQ0FBQ1QsU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLHFCQUNFLDZCQUFDVSwwQkFBaUI7UUFDaEJDLFdBQVdmO1FBQ1hnQixLQUFLWixRQUFRYSxHQUFHLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsUUFBUTtRQUN0Q0MsV0FBVyxDQUFDLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFO1lBQ3hDakIsV0FBVztnQkFDVGtCLFdBQVdGO2dCQUNYRyxTQUFTRjtZQUNYO1FBQ0Y7T0FFQ2xCLFFBQVFhLEdBQUcsQ0FBQyxDQUFDQyxLQUFLTztRQUNqQixNQUFNLEVBQUVDLElBQUksRUFBRVAsUUFBUSxFQUFFUSxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVjtRQUUxQyxJQUFJQSxJQUFJQyxRQUFRLEtBQUssV0FBVyxPQUFPO1FBRXZDLHFCQUNFLDZCQUFDVSxhQUFJO1lBQ0hDLFdBQVU7WUFDVkMsZ0JBQWNKO1lBQ2RaLFdBQVc7Z0JBQUMsQ0FBQyxFQUFFZixVQUFVLFFBQVEsQ0FBQztnQkFBRTJCLFVBQVUsQ0FBQyxFQUFFM0IsVUFBVSxnQkFBZ0IsQ0FBQzthQUFDLENBQzFFZ0MsTUFBTSxDQUFDQyxTQUNQQyxJQUFJLENBQUM7WUFDUkMsV0FBQUE7WUFDQUMsTUFBTVQsdUJBQVMsNkJBQUNVLFVBQUMsd0JBQU0sNkJBQUNDLGFBQUk7WUFDNUJDLElBQUlwQjtZQUNKcUIsS0FBSyxDQUFDLEVBQUVyQyxLQUFLLENBQUMsRUFBRWUsSUFBSVEsSUFBSSxJQUFJRCxFQUFFLEVBQUViLFlBQVksQ0FBQyxDQUFDLEVBQUVBLFVBQVUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFRixLQUFLLENBQUM7WUFDMUUrQixTQUFTO2dCQUNQbkMsYUFBYWE7WUFDZjtXQUVDdUIsSUFBQUEsOEJBQWMsRUFBQ2QsU0FBU0YsTUFBTWxCO0lBR3JDO0FBR047TUFFQSxXQUFlUCJ9